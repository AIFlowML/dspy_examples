---
description: DSPy dspy.ProgramOfThought Module
globs: 
alwaysApply: false
---
> You are an expert in DSPy, the framework for programming—not just prompting—foundation models. You focus on building modular, self-improving AI systems by composing declarative Python code.

## The `dspy.ProgramOfThought` Module

`dspy.ProgramOfThought` (PoT) is an advanced DSPy module that instructs a Language Model (LM) to generate a Python program to solve a given task. It then executes this program using a built-in, sandboxed Python interpreter and uses the output as the basis for the final answer.

This approach is particularly powerful for tasks requiring precise logical or mathematical computation, where traditional `dspy.ChainOfThought` might produce reasoning that is conceptually correct but contains small factual or arithmetic errors.

## Core Architecture

`ProgramOfThought` works by augmenting a standard signature. Internally, it reasons in a loop, generating and refining code until it produces a valid output. It implicitly uses the following fields in its process:

-   `final_generated_code`: The Python code generated by the LM.
-   `code_output`: The result from executing the `final_generated_code`.

```mermaid
graph TD
    A[Input Question] --> B{dspy.ProgramOfThought};
    B --> C[1. LM Generates Python Code];
    C --> D[2. dspy.PythonInterpreter Executes Code];
    D --> E[3. Execution Output is captured];
    E --> B;
    B --> F[Final Answer];
```

## Core Implementation Pattern

Using `dspy.ProgramOfThought` is as simple as using `dspy.ChainOfThought`. You declare it with a signature, and it handles the rest.

```python
import dspy

# ✅ DO: Use ProgramOfThought for computational tasks.
class BasicQA(dspy.Signature):
    """Answer questions with short factoid answers."""
    question = dspy.InputField()
    answer = dspy.OutputField()

# Define the module
pot_predictor = dspy.ProgramOfThought(BasicQA)

# A question where ChainOfThought might fail on the final division
question = "Compute 12! / sum of prime numbers between 1 and 30."

# Execute the prediction
result = pot_predictor(question=question)

print(f"Question: {question}")
print(f"Answer: {result.answer}")
# Probable Correct Output: 3713190.697674419

# ❌ DON'T: Use ChainOfThought for tasks requiring precise math.
cot_predictor = dspy.ChainOfThought(BasicQA)
bad_result = cot_predictor(question=question)

print(f"Answer from CoT: {bad_result.answer}")
# Probable Incorrect Output: 3,710,009 (due to division error)
```

## Inspecting the Generated Program

The power of PoT is its transparency. You can inspect the `dspy.history` to see the exact code that was generated and executed.

```python
# Assuming the previous call was made
dspy.settings.lm.history[-1]

# You will see the generated Python code in the prompt, like:
# def is_prime(n):
#     ...
#
# def sum_of_primes(start, end):
#     ...
#
# def factorial(n):
#     ...
#
# fact_12 = factorial(12)
# sum_primes = sum_of_primes(1, 30)
# result = fact_12 / sum_primes
# print(result)
```

## When to Use `ProgramOfThought`

-   **Mathematical & Scientific Questions**: When questions involve arithmetic, algebra, or other calculations.
-   **Logical Puzzles**: For problems that can be solved algorithmically.
-   **Data Manipulation**: When the task involves sorting, filtering, or transforming data in a structured way.
-   **Any task where computational accuracy is critical.**

## Best Practices

-   Start with a simple signature. PoT adds its own complexity internally, so the user-facing signature can often be just `question -> answer`.
-   Use `dspy.inspect_history()` to debug and understand how the LM is solving the problem.
-   For very complex problems, `ProgramOfThought` can be combined with other modules, like a search/retrieval tool, to gather facts before generating the final computational program.
-   Ensure your LM is capable of code generation (most modern models are).

## References
- [Tutorial: ProgramOfThought](mdc:extra/dspy/docs/docs/tutorials/program_of_thought/index.ipynb)
